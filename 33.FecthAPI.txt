/*

Fecth API provides an interface for fetching(sending and receiving) resources.

It uses Request and Response objects.

The fecth() method is used to fetch a resource(data)

*/

//let promise=fetch(url,[options])

/*
Basic Syn:
fetch(url, options)
  .then(response => {
    // handle response
  })
  .catch(error => {
    // handle error
  });
*/

/*
Alright — let’s do a **deep dive** into the **Fetch API in JavaScript** so you understand it from basics to advanced usage.
Think of this as a "from zero to pro" guide — with explanations, examples, best practices, and gotchas.

---

## 1. **What is Fetch API?**

The **Fetch API** is a modern way to make HTTP requests in JavaScript.
It’s used for getting (and sending) data from/to servers, replacing the older **XMLHttpRequest (XHR)** with a simpler and promise-based syntax.

Key points:

* **Built-in**: No library installation needed.
* **Promise-based**: Easier to work with async/await.
* **Supports JSON, text, blob, form data, etc.**

---

## 2. **Basic Syntax**

```javascript
fetch(url, options)
  .then(response => {
    // handle response
  })
  .catch(error => {
    // handle error
  });
```

* `url`: String — endpoint to call.
* `options`: Object — HTTP method, headers, body, etc. (optional).

---

## 3. **Making a Simple GET Request**

```javascript
fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => response.json()) // convert to JSON
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

**Note:**
`response.json()` also returns a Promise — because the body parsing happens asynchronously.

---

## 4. **Using async/await**

```javascript
async function getPost() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    const data = await response.json();
    console.log(data);
  } catch (err) {
    console.error('Error:', err);
  }
}
getPost();
```

✅ **`response.ok`** is `true` for status codes in range 200–299.

---

## 5. **HTTP Methods**

The `options` object lets you specify:

```javascript
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST', // GET, POST, PUT, PATCH, DELETE
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token_here'
  },
  body: JSON.stringify({
    title: 'Hello',
    body: 'This is a test',
    userId: 1
  })
})
  .then(res => res.json())
  .then(data => console.log(data));
```

---

## 6. **Common Response Methods**

* `.json()` → Parses JSON body.
* `.text()` → Returns plain text.
* `.blob()` → For binary data (e.g., images, PDFs).
* `.formData()` → For form data from a response.
* `.arrayBuffer()` → For raw binary data.

---

## 7. **Sending Form Data**

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('avatar', fileInput.files[0]);

fetch('/upload', {
  method: 'POST',
  body: formData
});
```

💡 You **don’t** need `Content-Type` for `FormData`; the browser sets it automatically.

---

## 8. **Handling Errors Properly**

⚠️ **Important:** Fetch only rejects on **network errors**, not on HTTP errors (like 404 or 500).

```javascript
fetch('/data')
  .then(response => {
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    return response.json();
  })
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

---

## 9. **Abort / Cancel Requests**

Using **AbortController**:

```javascript
const controller = new AbortController();
const signal = controller.signal;

fetch('/slow-api', { signal })
  .then(res => res.json())
  .then(console.log)
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('Fetch aborted!');
    }
  });

setTimeout(() => controller.abort(), 2000); // cancel after 2 sec
```

---

## 10. **Timeout Example**

```javascript
function fetchWithTimeout(url, options, timeout = 5000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  
  return fetch(url, { ...options, signal: controller.signal })
    .finally(() => clearTimeout(id));
}

fetchWithTimeout('/api', {}, 3000)
  .then(res => res.json())
  .then(console.log)
  .catch(console.error);
```

---

## 11. **Streaming Data**

```javascript
fetch('/large-file')
  .then(response => {
    const reader = response.body.getReader();
    return reader.read().then(function process({ done, value }) {
      if (done) return;
      console.log(`Received ${value.length} bytes`);
      return reader.read().then(process);
    });
  });
```

---

## 12. **CORS (Cross-Origin Resource Sharing)**

If you fetch data from another domain:

* The server must allow it via `Access-Control-Allow-Origin` header.
* Otherwise, you get a **CORS error**.

Example:

```javascript
fetch('https://api.example.com/data', { mode: 'cors' })
```

Modes:

* `cors` (default for cross-origin)
* `same-origin`
* `no-cors`

---

## 13. **Fetch vs XMLHttpRequest**

| Feature       | Fetch API       | XMLHttpRequest |
| ------------- | --------------- | -------------- |
| Syntax        | Promise-based   | Callback-based |
| Streaming     | Yes             | No             |
| Abort         | AbortController | `xhr.abort()`  |
| CORS Handling | Built-in        | Manual         |
| Simplicity    | Cleaner, modern | Older, verbose |

---

## 14. **Best Practices**

* Always check `response.ok` before parsing.
* Use **async/await** for readability.
* Implement **timeout & abort** for long requests.
* Handle **CORS** issues on the server side.
* Avoid blocking the UI — fetch is async.
* Sanitize user inputs when sending to a server.


*/